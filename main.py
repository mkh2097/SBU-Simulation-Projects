# -*- coding: utf-8 -*-
"""Untitled19.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hfq4pfdUY4zzufcMeaR22X3-ljvNAGM3
"""

import networkx as nx
import numpy as np
import random
import time
import matplotlib.pyplot as plt

"""### **Request 1**

"""


def draw_graph(G):
    pos = nx.spring_layout(G)
    nx.draw(G, pos=pos, with_labels=True)
    plt.savefig('fig.png', bbox_inches='tight')


def make_erdos_renyi_graph(node_num, prob):
    G = nx.erdos_renyi_graph(n=node_num, p=prob)
    draw_graph(G)


def make_barabasi_albert_graph(node_num, attach_num):
    G = nx.barabasi_albert_graph(n=node_num, m=attach_num)
    draw_graph(G)


def make_watts_strogatz_graph(node_num, prob, k_nearest):
    G = nx.watts_strogatz_graph(n=node_num, k=k_nearest, p=prob)
    print(G)
    draw_graph(G)


make_erdos_renyi_graph(10, 0.4)

make_barabasi_albert_graph(10, 3)

make_watts_strogatz_graph(10, 0.5, 6)

"""### **Request 2 & 3**

"""

import networkx as nx
import numpy as np
import random
import time
import matplotlib.pyplot as plt


def magic(number_nodes, mode, sub_mode, eliminated_number, probability=0, new_node_edges=0, neighbors=0):
    if mode == 1:
        G = nx.erdos_renyi_graph(n=number_nodes, p=probability)
    elif mode == 2:
        G = nx.barabasi_albert_graph(n=number_nodes, m=new_node_edges)
    elif mode == 3:
        G = nx.watts_strogatz_graph(n=number_nodes, k=neighbors, p=probability)

    if sub_mode == 0:

        edges = list(G.edges())
        # print (edges)
        indices_edges = [i for i in range(len(edges))]
        if len(edges) < eliminated_number:
            eliminated_number = len(edges)
        selected_edges = list(np.random.choice(indices_edges, eliminated_number, replace=False))

        # print (selected_edges)
        for i in selected_edges:
            # print("Log Edges:", edges[i][0], edges[i][1])
            G.remove_edge(edges[i][0], edges[i][1])
    elif sub_mode == 1:
        nodes = list(G.nodes())
        indices_nodes = [i for i in range(len(nodes))]
        temp_eliminated_number = eliminated_number
        if len(nodes) - 1 < eliminated_number:
            eliminated_number = len(nodes) - 1
        # if number_nodes - 1 <= temp_eliminated_number:
        #   return 0, number_nodes
        selected_nodes = list(np.random.choice(indices_nodes, eliminated_number, replace=False))
        for i in selected_nodes:
            G.remove_node(nodes[i])
            # print("Log Nodes:", nodes[i])
    # print("The graph:", G)

    # print("Edges: ", edges)
    # print("Selected edges:", selected_edges)

    # print("Nodes: ", nodes)
    # print("Selected nodes:", selected_nodes)

    connectivity = nx.is_connected(G)
    number_of_connected_comps = nx.number_connected_components(G)
    num_isolated_nodes = len(list(nx.isolates(G)))

    return int(connectivity), num_isolated_nodes

    # pos = nx.spring_layout(G)
    # nx.draw(G, pos=pos, with_labels=True)
    # plt.savefig('fig.png',bbox_inches='tight')


# if __name__ == "__main__":
#     while True:
#         graph_mode = int(input("####### Graph Mode #######\n1.ER Graph\n2.BA Graph\n3.WS Graph\nEnter Mode: "))

def draw(n, num_of_elimination, connectivity, isolation, sub_mode):
    fig, axs = plt.subplots(1, 2, figsize=(14, 7))

    text = "edges" if sub_mode == 0 else "nodes"

    axs[0].plot(np.arange(0, num_of_elimination) / num_of_elimination, 1 - np.array(connectivity))
    axs[0].set_xlabel('percentage of corrupted ' + text)
    axs[0].set_ylabel('probability of disconnection')

    axs[1].plot(np.arange(0, num_of_elimination) / num_of_elimination, np.array(isolation) / n)
    axs[1].set_xlabel('percentage of corrupted ' + text)
    axs[1].set_ylabel('probability of isolation')

    plt.show()


def run(num_of_elimination, exp_repetition, mode, sub_mode, n, p=0, k=0, m=0):
    # n = 20
    # p = 0.3

    connectivity = []
    isolation = []

    # num_of_elimination = 220
    # exp_repetition = 100

    for j in range(num_of_elimination):
        sum_connectivity = 0
        sum_isolated = 0
        counter = 0
        for i in range(exp_repetition):
            if mode == 1:
                out = magic(number_nodes=n, probability=p, mode=mode, sub_mode=sub_mode, eliminated_number=j)
            elif mode == 2:
                out = magic(number_nodes=n, new_node_edges=m, mode=mode, sub_mode=sub_mode, eliminated_number=j)
            elif mode == 3:
                out = magic(number_nodes=n, probability=p, mode=mode, sub_mode=sub_mode, eliminated_number=j,
                            neighbors=k)

            sum_connectivity += out[0]
            sum_isolated += out[1]
        connectivity.append(sum_connectivity / exp_repetition)
        isolation.append(sum_isolated / exp_repetition)

    print(connectivity, isolation, sep='\n')
    draw(n, num_of_elimination, connectivity, isolation, sub_mode=sub_mode)


"""### **ER**"""

run(num_of_elimination=100, exp_repetition=100, mode=1, sub_mode=0, n=20, p=0.45)
run(num_of_elimination=50, exp_repetition=100, mode=1, sub_mode=1, n=20, p=0.45)

"""### **BA**"""

run(num_of_elimination=100, exp_repetition=100, mode=2, sub_mode=0, n=20, m=6)
run(num_of_elimination=50, exp_repetition=100, mode=2, sub_mode=1, n=20, m=6)

"""### **WS**"""

run(num_of_elimination=100, exp_repetition=1, mode=3, sub_mode=0, n=20, p=0.45, k=2)
run(num_of_elimination=100, exp_repetition=1, mode=3, sub_mode=1, n=20, p=0.45, k=2)